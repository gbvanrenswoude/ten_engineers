<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ten Engineers</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: monospace; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 1px solid #fff; display: none; }
        #menu { text-align: center; white-space: pre; font-size: 16px; }
        #startButton { margin-top: 20px; padding: 10px 20px; background: #fff; color: #000; border: none; cursor: pointer; }
        #startButton:hover { background: #ccc; }
    </style>
</head>
<body>
    <div id="menu">
        <pre>
        ======================================
        |          TEN ENGINEERS RTS         |
        ======================================
        |                                    |
        |       .-""""""""-""""""""-.       |
        |     .'          |          '.     |
        |    /   ____     |     ____   \    |
        |   : , |    |    |    |    | , :   |
        |    `._|    |____|____|    |_.'    |
        |       |   Engineer    |            |
        |       |               |            |
        |       `._          _.'             |
        |          `"'"""""'"`               |
        |                                    |
        ======================================
        |  Build factories, mine ore, fight! |
        |  Left-click: Drag to select units  |
        |  Left-click again: Move selected   |
        |  Right-click: Deselect units       |
        |  Right-click engineer: Factory(2000)|
        |  Win by destroying enemy engineers |
        ======================================
        </pre>
        <button id="startButton">Start Game</button>
    </div>

    <script>
        if (typeof Phaser === 'undefined') {
            document.body.innerHTML = '<h1 style="color: #fff;">Error: Phaser failed to load. Check your internet or CDN.</h1>';
        }

        const config = {
            type: Phaser.AUTO,
            width: 1600, 
            height: 1200, 
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: { debug: false }
            }
        };

        let game, player, enemy, playerCredits = 10000, enemyCredits = 10000;
        let playerEngineers = [], enemyEngineers = [], playerFactories = [], enemyFactories = [];
        let playerUnits = [], enemyUnits = [], selectedUnits = []; 
        let ores = [], selectionBox = null;

        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('menu').style.display = 'none';
            game = new Phaser.Game(config);
            setTimeout(() => {
                let canvas = document.getElementsByTagName('canvas')[0];
                if (canvas) {
                    canvas.style.display = 'block';
                } else {
                    console.error('Canvas not found after game start.');
                }
            }, 100);
        });

        function preload() {
        }

        function create() {
            this.add.rectangle(800, 600, 1600, 1200, 0x006400);

            // UI
            player = { creditsText: this.add.text(10, 10, `Credits: ${playerCredits}`, { color: '#fff' }) };
            enemy = { creditsText: this.add.text(10, 30, `Enemy Credits: ${enemyCredits}`, { color: '#fff' }) };

            for (let i = 0; i < 10; i++) {
                let eng = this.add.rectangle(100 + i * 60, 1100, 20, 20, 0xffff00); 
                eng.health = 50;
                eng.team = 'player';
                playerEngineers.push(eng);

                let enemyEng = this.add.rectangle(100 + i * 60, 100, 20, 20, 0xff0000); 
                enemyEng.health = 50;
                enemyEng.team = 'enemy';
                enemyEngineers.push(enemyEng);
            }

            for (let i = 0; i < 10; i++) { 
                let ore = this.add.rectangle(Phaser.Math.Between(200, 1400), Phaser.Math.Between(200, 1000), 30, 30, 0x8b4513);
                ore.resource = 1000;
                ores.push(ore);
            }

            this.input.on('pointerdown', (pointer) => handleClick.call(this, pointer));
        }

        function update() {
            if (selectionBox) {
                selectionBox.setSize(this.input.activePointer.x - selectionBox.x, this.input.activePointer.y - selectionBox.y);
            }

            playerEngineers.forEach(eng => mineOre.call(this, eng, 'player'));
            enemyEngineers.forEach(eng => mineOre.call(this, eng, 'enemy'));

            playerUnits.forEach(unit => {
                fireBullet.call(this, unit, enemyUnits.concat(enemyEngineers));
                if (selectedUnits.includes(unit)) drawSelectionOutline.call(this, unit, 0x0000ff); // Blue outline for selected
            });
            enemyUnits.forEach(unit => {
                fireBullet.call(this, unit, playerUnits.concat(playerEngineers));
                if (selectedUnits.includes(unit)) drawSelectionOutline.call(this, unit, 0x0000ff); // Blue outline for selected
            });

            playerFactories.forEach(factory => produceUnit.call(this, factory, 'player'));
            enemyFactories.forEach(factory => produceUnit.call(this, factory, 'enemy'));

            if (playerEngineers.length === 0) endGame('Enemy Wins!');
            if (enemyEngineers.length === 0) endGame('Player Wins!');
        }

        function handleClick(pointer) {
            if (pointer.leftButtonDown()) {
                if (!selectionBox) {
                    selectionBox = this.add.rectangle(pointer.x, pointer.y, 1, 1, 0x0000ff, 0.5);
                    selectionBox.isSelecting = true;
                } else if (selectionBox.isSelecting) {
                    let x1 = selectionBox.x, y1 = selectionBox.y;
                    let x2 = pointer.x, y2 = pointer.y;
                    let minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                    let minY = Math.min(y1, y2), maxY = Math.max(y1, y2);

                    selectedUnits = [...playerUnits, ...playerEngineers].filter(entity => {
                        return entity.x >= minX && entity.x <= maxX && entity.y >= minY && entity.y <= maxY;
                    });

                    selectionBox.destroy();
                    selectionBox = null;
                } else {
                    if (selectedUnits.length > 0) {
                        let target = { x: pointer.x, y: pointer.y };
                        selectedUnits.forEach(entity => {
                            entity.target = target;
                        });
                    }
                }
            } else if (pointer.rightButtonDown()) {
                selectedUnits = [];
                if (selectionBox) {
                    selectionBox.destroy();
                    selectionBox = null;
                }

                let selectedEng = playerEngineers.find(eng => Phaser.Math.Distance.Between(eng.x, eng.y, pointer.x, pointer.y) < 20);
                if (selectedEng && playerCredits >= 2000) {
                    let factory = this.add.rectangle(selectedEng.x, selectedEng.y, 40, 40, 0xd3d3a4); 
                    factory.health = 200;
                    factory.team = 'player';
                    factory.lastSpawn = 0;
                    playerFactories.push(factory);
                    playerCredits -= 2000;
                    player.creditsText.setText(`Credits: ${playerCredits}`);
                }
            }
        }

        function mineOre(eng, team) {
            if (eng.target && !eng.mining) {
                let dist = Phaser.Math.Distance.Between(eng.x, eng.y, eng.target.x, eng.target.y);
                if (dist > 20) {
                    let angle = Phaser.Math.Angle.Between(eng.x, eng.y, eng.target.x, eng.target.y);
                    eng.x += Math.cos(angle) * 2;
                    eng.y += Math.sin(angle) * 2;
                } else if (eng.target.resource) {
                    eng.mining = true;
                    this.time.delayedCall(1000, () => {
                        if (eng.target.resource > 0) {
                            eng.target.resource -= 10;
                            if (team === 'player') {
                                playerCredits += 10;
                                player.creditsText.setText(`Credits: ${playerCredits}`);
                            } else {
                                enemyCredits += 10;
                                enemy.creditsText.setText(`Enemy Credits: ${enemyCredits}`);
                            }
                            if (eng.target.resource <= 0) ores = ores.filter(o => o !== eng.target);
                        }
                        eng.mining = false;
                    });
                }
            }
        }

        function produceUnit(factory, team) {
            let credits = team === 'player' ? playerCredits : enemyCredits;
            if (credits >= 500 && this.time.now - factory.lastSpawn > 3000) {
                let size = Phaser.Math.Between(20, 40);
                let unit = this.add.rectangle(factory.x + 100, factory.y, size, size, 
                    team === 'player' ? 0xffd700 : 0x8b0000); 
                unit.health = size * 5;
                unit.team = team;
                unit.lastShot = 0;
                (team === 'player' ? playerUnits : enemyUnits).push(unit);
                if (team === 'player') {
                    playerCredits -= 500;
                    player.creditsText.setText(`Credits: ${playerCredits}`);
                } else {
                    enemyCredits -= 500;
                    enemy.creditsText.setText(`Enemy Credits: ${enemyCredits}`);
                }
                factory.lastSpawn = this.time.now;
            }
        }

        function fireBullet(unit, targets) {
            if (this.time.now - unit.lastShot > 1000) {
                let target = targets.find(t => Phaser.Math.Distance.Between(unit.x, unit.y, t.x, t.y) < 200);
                if (target) {
                    let bullet = this.add.rectangle(unit.x, unit.y, 4, 4, 0xffffff);
                    this.tweens.add({
                        targets: bullet,
                        x: target.x,
                        y: target.y,
                        duration: 500,
                        onComplete: () => {
                            bullet.destroy();
                            target.health -= 10;
                            if (target.health <= 0) {
                                target.destroy();
                                if (target.team === 'player') {
                                    if (playerUnits.includes(target)) playerUnits = playerUnits.filter(u => u !== target);
                                    else playerEngineers = playerEngineers.filter(e => e !== target);
                                } else {
                                    if (enemyUnits.includes(target)) enemyUnits = enemyUnits.filter(u => u !== target);
                                    else enemyEngineers = enemyEngineers.filter(e => e !== target);
                                }
                            }
                        }
                    });
                    unit.lastShot = this.time.now;
                }
            }
        }

        function drawSelectionOutline(entity, color) {
            this.add.rectangle(entity.x, entity.y, entity.width + 4, entity.height + 4, color, 0.5)
                .setStrokeStyle(2, 0x0000ff, 1);
        }

        function endGame(message) {
            this.add.text(800, 600, message, { fontSize: '32px', color: '#fff' }).setOrigin(0.5);
            this.scene.pause();
        }
    </script>
</body>
</html>
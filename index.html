<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ten Engineers</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: monospace; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 1px solid #fff; display: none; }
        #menu { text-align: center; white-space: pre; font-size: 16px; }
        #startButton { margin-top: 20px; padding: 10px 20px; background: #fff; color: #000; border: none; cursor: pointer; }
        #startButton:hover { background: #ccc; }
    </style>
</head>
<body>
    <div id="menu">
        <pre>
        ======================================
        |          TEN ENGINEERS RTS         |
        ======================================
        |                                    |
        |       .-""""""""-""""""""-.       |
        |     .'          |          '.     |
        |    /   ____     |     ____   \    |
        |   : , |    |    |    |    | , :   |
        |    `._|    |____|____|    |_.'    |
        |       |   Engineer    |            |
        |       |               |            |
        |       `._          _.'             |
        |          `"'"""""'"`               |
        |                                    |
        ======================================
        |  Build factories, mine ore, fight! |
        |  Left-click: Drag to select units  |
        |  Left-click again: Move selected   |
        |  Right-click: Deselect units       |
        |  Right-click engineer: Factory(2000)|
        |  Win by destroying enemy engineers |
        |  Hover edges to scroll map (Esc to unlock cursor) |
        ======================================
        </pre>
        <button id="startButton">Start Game</button>
    </div>

    <script>
        if (typeof Phaser === 'undefined') {
            document.body.innerHTML = '<h1 style="color: #fff;">Error: Phaser failed to load. Check your internet or CDN.</h1>';
        }

        const config = {
            type: Phaser.AUTO,
            width: 1600,
            height: 1200,
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: { debug: false }
            }
        };

        let game, player, enemy, playerCredits = 10000, enemyCredits = 10000;
        let playerEngineers = [], enemyEngineers = [], playerFactories = [], enemyFactories = [];
        let playerUnits = [], enemyUnits = [], selectedUnits = [];
        let ores = [], selectionBox = null;
        let camera, isCursorLocked = false;

        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('menu').style.display = 'none';
            game = new Phaser.Game(config);
            setTimeout(() => {
                let canvas = document.getElementsByTagName('canvas')[0];
                if (canvas) {
                    canvas.style.display = 'block';
                    lockCursor(canvas); // Lock cursor when game starts
                } else {
                    console.error('Canvas not found after game start.');
                }
            }, 100);
        });

        function preload() {
        }

        function create() {
            camera = this.cameras.main;
            camera.setBounds(0, 0, 1600, 1200);
            camera.setZoom(1);

            this.add.rectangle(800, 600, 1600, 1200, 0x006400);

            player = { creditsText: this.add.text(10, 10, `Credits: ${playerCredits}`, { color: '#fff' }).setScrollFactor(0) };
            enemy = { creditsText: this.add.text(10, 30, `Enemy Credits: ${enemyCredits}`, { color: '#fff' }).setScrollFactor(0) };

            for (let i = 0; i < 10; i++) {
                let eng = this.add.rectangle(100 + i * 60, 1100, 20, 20, 0xffff00); // Golden Yellow
                eng.health = 50;
                eng.team = 'player';
                playerEngineers.push(eng);

                let enemyEng = this.add.rectangle(100 + i * 60, 100, 20, 20, 0xff0000); // Bright Red
                enemyEng.health = 50;
                enemyEng.team = 'enemy';
                enemyEngineers.push(enemyEng);
            }

            for (let i = 0; i < 10; i++) { // Brown ore
                let ore = this.add.rectangle(Phaser.Math.Between(200, 1400), Phaser.Math.Between(200, 1000), 30, 30, 0x8b4513);
                ore.resource = 1000;
                ores.push(ore);
            }

            this.input.on('pointerdown', (pointer) => handleClick.call(this, pointer));

            // Add keyboard input for Esc to unlock cursor
            this.input.keyboard.on('keydown-ESC', () => {
                unlockCursor();
            });
        }

        function update() {
            const edgeThreshold = 50;
            const scrollSpeed = 10;

            if (isCursorLocked) {
                // Use pointer position within the canvas for scrolling
                if (this.input.activePointer.x < edgeThreshold) {
                    camera.scrollX -= scrollSpeed;
                } else if (this.input.activePointer.x > config.width - edgeThreshold) {
                    camera.scrollX += scrollSpeed;
                }
                if (this.input.activePointer.y < edgeThreshold) {
                    camera.scrollY -= scrollSpeed;
                } else if (this.input.activePointer.y > config.height - edgeThreshold) {
                    camera.scrollY += scrollSpeed;
                }

                camera.scrollX = Phaser.Math.Clamp(camera.scrollX, 0, 1600 - config.width);
                camera.scrollY = Phaser.Math.Clamp(camera.scrollY, 0, 1200 - config.height);
            }

            if (selectionBox) {
                selectionBox.setSize(this.input.activePointer.x - selectionBox.x, this.input.activePointer.y - selectionBox.y);
            }

            playerEngineers.forEach(eng => mineOre.call(this, eng, 'player'));
            enemyEngineers.forEach(eng => mineOre.call(this, eng, 'enemy'));

            playerUnits.forEach(unit => {
                fireBullet.call(this, unit, enemyUnits.concat(enemyEngineers));
                if (selectedUnits.includes(unit)) drawSelectionOutline.call(this, unit, 0x0000ff); // Blue outline for selected
            });
            enemyUnits.forEach(unit => {
                fireBullet.call(this, unit, playerUnits.concat(playerEngineers));
                if (selectedUnits.includes(unit)) drawSelectionOutline.call(this, unit, 0x0000ff); // Blue outline for selected
            });

            playerFactories.forEach(factory => produceUnit.call(this, factory, 'player'));
            enemyFactories.forEach(factory => produceUnit.call(this, factory, 'enemy'));

            if (playerEngineers.length === 0) endGame('Enemy Wins!');
            if (enemyEngineers.length === 0) endGame('Player Wins!');
        }

        function handleClick(pointer) {
            if (isCursorLocked) {
                if (pointer.leftButtonDown()) {
                    if (!selectionBox) {
                        selectionBox = this.add.rectangle(pointer.x + camera.scrollX, pointer.y + camera.scrollY, 1, 1, 0x0000ff, 0.5);
                        selectionBox.isSelecting = true;
                    } else if (selectionBox.isSelecting) {
                        let x1 = selectionBox.x, y1 = selectionBox.y;
                        let x2 = pointer.x + camera.scrollX, y2 = pointer.y + camera.scrollY;
                        let minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                        let minY = Math.min(y1, y2), maxY = Math.max(y1, y2);

                        selectedUnits = [...playerUnits, ...playerEngineers].filter(entity => {
                            return entity.x >= minX && entity.x <= maxX && entity.y >= minY && entity.y <= maxY;
                        });

                        selectionBox.destroy();
                        selectionBox = null;
                    } else {
                        if (selectedUnits.length > 0) {
                            let target = { x: pointer.x + camera.scrollX, y: pointer.y + camera.scrollY };
                            selectedUnits.forEach(entity => {
                                entity.target = target;
                            });
                        }
                    }
                } else if (pointer.rightButtonDown()) {
                    selectedUnits = [];
                    if (selectionBox) {
                        selectionBox.destroy();
                        selectionBox = null;
                    }

                    let selectedEng = playerEngineers.find(eng => Phaser.Math.Distance.Between(eng.x, eng.y, pointer.x + camera.scrollX, pointer.y + camera.scrollY) < 20);
                    if (selectedEng && playerCredits >= 2000) {
                        let factory = this.add.rectangle(selectedEng.x, selectedEng.y, 40, 40, 0xd3d3a4); // Grey-Yellowish
                        factory.health = 200;
                        factory.team = 'player';
                        factory.lastSpawn = 0;
                        playerFactories.push(factory);
                        playerCredits -= 2000;
                        player.creditsText.setText(`Credits: ${playerCredits}`);
                    }
                }
            }
        }

        function mineOre(eng, team) {
            if (eng.target && !eng.mining) {
                let dist = Phaser.Math.Distance.Between(eng.x, eng.y, eng.target.x, eng.target.y);
                if (dist > 20) {
                    let angle = Phaser.Math.Angle.Between(eng.x, eng.y, eng.target.x, eng.target.y);
                    eng.x += Math.cos(angle) * 2;
                    eng.y += Math.sin(angle) * 2;
                } else if (eng.target.resource) {
                    eng.mining = true;
                    this.time.delayedCall(1000, () => {
                        if (eng.target.resource > 0) {
                            eng.target.resource -= 10;
                            if (team === 'player') {
                                playerCredits += 10;
                                player.creditsText.setText(`Credits: ${playerCredits}`);
                            } else {
                                enemyCredits += 10;
                                enemy.creditsText.setText(`Enemy Credits: ${enemyCredits}`);
                            }
                            if (eng.target.resource <= 0) ores = ores.filter(o => o !== eng.target);
                        }
                        eng.mining = false;
                    });
                }
            }
        }

        function produceUnit(factory, team) {
            let credits = team === 'player' ? playerCredits : enemyCredits;
            if (credits >= 500 && this.time.now - factory.lastSpawn > 3000) {
                let size = Phaser.Math.Between(20, 40);
                let unit = this.add.rectangle(factory.x + 100, factory.y, size, size, 
                    team === 'player' ? 0xffd700 : 0x8b0000); // Golden Yellow for player, Dark Red for enemy
                unit.health = size * 5;
                unit.team = team;
                unit.lastShot = 0;
                (team === 'player' ? playerUnits : enemyUnits).push(unit);
                if (team === 'player') {
                    playerCredits -= 500;
                    player.creditsText.setText(`Credits: ${playerCredits}`);
                } else {
                    enemyCredits -= 500;
                    enemy.creditsText.setText(`Enemy Credits: ${enemyCredits}`);
                }
                factory.lastSpawn = this.time.now;
            }
        }

        function fireBullet(unit, targets) {
            if (this.time.now - unit.lastShot > 1000) {
                let target = targets.find(t => Phaser.Math.Distance.Between(unit.x, unit.y, t.x, t.y) < 200);
                if (target) {
                    let bullet = this.add.rectangle(unit.x, unit.y, 4, 4, 0xffffff);
                    this.tweens.add({
                        targets: bullet,
                        x: target.x,
                        y: target.y,
                        duration: 500,
                        onComplete: () => {
                            bullet.destroy();
                            target.health -= 10;
                            if (target.health <= 0) {
                                target.destroy();
                                if (target.team === 'player') {
                                    if (playerUnits.includes(target)) playerUnits = playerUnits.filter(u => u !== target);
                                    else playerEngineers = playerEngineers.filter(e => e !== target);
                                } else {
                                    if (enemyUnits.includes(target)) enemyUnits = enemyUnits.filter(u => u !== target);
                                    else enemyEngineers = enemyEngineers.filter(e => e !== target);
                                }
                            }
                        }
                    });
                    unit.lastShot = this.time.now;
                }
            }
        }

        function drawSelectionOutline(entity, color) {
            this.add.rectangle(entity.x, entity.y, entity.width + 4, entity.height + 4, color, 0.5)
                .setStrokeStyle(2, 0x0000ff, 1);
        }

        function endGame(message) {
            this.add.text(800, 600, message, { fontSize: '32px', color: '#fff' }).setOrigin(0.5);
            this.scene.pause();
            unlockCursor(); gi
        }

        function lockCursor(canvas) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
            isCursorLocked = true;
            document.addEventListener('pointerlockchange', handlePointerLockChange, false);
        }

        function unlockCursor() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
            document.exitPointerLock();
            isCursorLocked = false;
        }

        function handlePointerLockChange() {
            isCursorLocked = document.pointerLockElement === document.getElementsByTagName('canvas')[0];
            if (!isCursorLocked) {
                console.log('Cursor unlocked');
            }
        }
    </script>
</body>
</html>